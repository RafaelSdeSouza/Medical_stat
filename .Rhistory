n.chains = 3)
Normfit <- run.jags(data = model.data,
adapt = 10000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 5,
burnin = 2000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 20000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 10,
burnin = 1000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 1000,
sample = 10000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 50,
burnin = 1000,
sample = 2000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
65000/12
123500000/12
65000000*0.81
52650000/12
98280/7.8
998280/7.8
127984.6/12
1346940/7.8
172684.6/12
14000*3.2
2700*3.3
4*5
2700/5
2300+500
2800/5
3200+560
3760*3.3
3760*3.4
900*3.4
900*3.42
900*4
3700*4
830/1596
install.packages("rJava",type = "source",http://rforge.net")
install.packages("rJava",type = "source","http://rforge.net")
install.packages("rJava",type = "source",,"http://rforge.net")
# From: Bayesian Models for Astrophysical Data, Cambridge Univ. Press
# (c) 2017,  Joseph M. Hilbe, Rafael S. de Souza and Emille E. O. Ishida
#
# you are kindly asked to include the complete citation if you used this
# material in a publication
# Code 4.10 - Normal linear model in R using JAGS and including errors in variables
require(R2jags)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
errx <- rnorm(nobs, 0, sdobsx)
obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Diffuse normal priors for true x
for (i in 1:N){
x[i] ~ dnorm(0,1e-3)
}
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
obsx[i] ~ dnorm(x[i],pow(errx[i],-2))
mu[i] <- beta[1]+beta[2]*x[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*truex[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
errx
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
obsx <- truex
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
erry
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Level of  mistake in the reported errors
Lambda <- 0.5
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = Lambda*erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
setwd("~/")
erry
library(shiny)
library(DT)
shinyApp(
ui = fluidPage(
dataTableOutput('table'),
verbatimTextOutput('hoverIndex')
),
server = function(server, input, output) {
output$hoverIndex <- renderText({
paste("hover column info", input$hoverIndexJS)
})
output$table <- renderDataTable({
datatable(data.frame(`A` = 1:5, `B` = 11:15, `C` = LETTERS[1:5]),
rownames = F,
callback = JS("
table.on('mouseenter', 'td', function() {
Shiny.onInputChange('hoverIndexJS', this.innerHTML);
});
return table;
")
)
})
}
)
175/8
175*4
library("TDA", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
Diag <- matrix(c(0, 0, 10, 1, 0, 3, 1, 3, 8), ncol = 3, byrow = TRUE)
DiagLim <- 10
colnames(Diag) <- c("dimension", "Birth", "Death")
#persistence landscape
tseq <- seq(0,DiagLim, length = 1000)
Land <- landscape(Diag, dimension = 1, KK = 1, tseq)
par(mfrow = c(1,2))
plot.diagram(Diag)
plot(tseq, Land, type = "l", xlab = "t", ylab = "landscape", asp = 1)
library(dplyr)
library(tidyr)
library(DT)
library(sparkline)
dat <- readRDS("data.rds")
datatable(dat, rownames = FALSE)
dat <- iris3
datatable(dat, rownames = FALSE)
dat <- iris
datatable(dat, rownames = FALSE)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
js <- "function(data, type, full){ return '<span class=spark>' + data + '</span>' }"
colDefs1 <- list(list(targets = c(1:3), render = JS(js)))
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Var == "Species")$Val)
dat
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Species == "setosa")$Val)
filter(dat, Species == "setosa")
range(dat$Petal.Length)
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
d1
# Pregnancy data
require(dplyr)
require(magrittr)
require(mgcv)
require(visreg)
library(FactoMineR)
require(caret)
library("factoextra")
library(pROC)
require(PRROC)
library(lime)
preg <- read.csv("BTA-Patients-MAW.csv") %>% select(c("BECOME_PREGNANT","TUBELENGTH_R_DISTAL","PREGNANT_NUMERIC",
"TUBELENGTH_L_DISTAL","LIGATION_GROUP",
"AGE","RIGHT_TUBE_LENGTH","LEFT_TUBE_LENGTH",
"TUBELENGTH_R_PROX","TUBELENGTH_L_PROX","AV_TUBELENGTH_GP")) %>%
filter(AGE != "Yes") %>%  mutate(AGE = as.numeric(as.character(AGE)) )  %>%
filter(AGE > 10) %>%
na.omit() %>% mutate(LEFT_TUBE_LENGTH = as.numeric(as.character(LEFT_TUBE_LENGTH)) ) %>%
mutate(PCA_TUBE_LENGTH = -prcomp(data.frame(RIGHT_TUBE_LENGTH,LEFT_TUBE_LENGTH))$x[,1]) %>%
filter(BECOME_PREGNANT %in% c("Yes","No")) %>% droplevels()
trainIndex <- createDataPartition(preg$BECOME_PREGNANT, p = .5,
list = FALSE,
times = 1)
Train <- preg[trainIndex,]
Test  <- preg[-trainIndex,]
fit0 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)   + LIGATION_GROUP,data=Train,family = binomial(link="logit"))
fit <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)  + AV_TUBELENGTH_GP  + LIGATION_GROUP,data=Train,family= binomial(link="logit"))
fit2 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)  + s(PCA_TUBE_LENGTH,bs="cr",k=15)  + LIGATION_GROUP,data=Train,family= binomial(link="logit"))
setwd("~/Documents/GitHub/Medical_stat")
# Pregnancy data
require(dplyr)
require(magrittr)
require(mgcv)
require(visreg)
library(FactoMineR)
require(caret)
library("factoextra")
library(pROC)
require(PRROC)
library(lime)
preg <- read.csv("BTA-Patients-MAW.csv") %>% select(c("BECOME_PREGNANT","TUBELENGTH_R_DISTAL","PREGNANT_NUMERIC",
"TUBELENGTH_L_DISTAL","LIGATION_GROUP",
"AGE","RIGHT_TUBE_LENGTH","LEFT_TUBE_LENGTH",
"TUBELENGTH_R_PROX","TUBELENGTH_L_PROX","AV_TUBELENGTH_GP")) %>%
filter(AGE != "Yes") %>%  mutate(AGE = as.numeric(as.character(AGE)) )  %>%
filter(AGE > 10) %>%
na.omit() %>% mutate(LEFT_TUBE_LENGTH = as.numeric(as.character(LEFT_TUBE_LENGTH)) ) %>%
mutate(PCA_TUBE_LENGTH = -prcomp(data.frame(RIGHT_TUBE_LENGTH,LEFT_TUBE_LENGTH))$x[,1]) %>%
filter(BECOME_PREGNANT %in% c("Yes","No")) %>% droplevels()
trainIndex <- createDataPartition(preg$BECOME_PREGNANT, p = .5,
list = FALSE,
times = 1)
Train <- preg[trainIndex,]
Test  <- preg[-trainIndex,]
fit0 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)   + LIGATION_GROUP,data=Train,family = binomial(link="logit"))
fit <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)  + AV_TUBELENGTH_GP  + LIGATION_GROUP,data=Train,family= binomial(link="logit"))
fit2 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)  + s(PCA_TUBE_LENGTH,bs="cr",k=15)  + LIGATION_GROUP,data=Train,family= binomial(link="logit"))
x1=anova(fit2)$chi.sq-anova(fit2)$edf
x2=anova(Beta_GAM)$chi.sq-anova(Beta_GAM)$edf
x3=x1+x2
pred0 <- predict(fit0,newdata = Test[,-1],type="response")
pred1 <- predict(fit,newdata = Test[,-1],type="response")
pred2 <- predict(fit2,newdata = Test[,-1],type="response")
plot(roc(Test$BECOME_PREGNANT, pred0, direction="<"),print.auc=TRUE,
lwd=3)
plot(roc(Test$BECOME_PREGNANT, pred1, direction="<"),print.auc=TRUE,
lwd=3)
plot.roc(Test$BECOME_PREGNANT,pred0,
percent=TRUE,  ci=TRUE, print.auc=TRUE,
thresholds="best",
print.thres="best")
plot.roc(Test$BECOME_PREGNANT,pred2,
percent=TRUE,  ci=TRUE, print.auc=TRUE,
thresholds="best",
print.thres="best")
pr <- pr.curve(scores.class0 = Test$BECOME_PREGNANT, weights.class0 = pred2,curve = TRUE)
fitglm0 <- glm(BECOME_PREGNANT~ AGE   + LIGATION_GROUP,data=Train,family = binomial(link="logit"))
predglm0 <- predict(fitglm0,newdata = Test[,-1],type="response")
PRAUC(y_pred = as.numeric(predglm0), y_true = Test$BECOME_PREGNANT)
ggplot(data.frame(pr$curve),aes(x=X1,y=X2,color=X3)) + geom_line()
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AV_TUBELENGTH_GP",scale="response")
visreg(fit2,"PCA_TUBE_LENGTH",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="PC1",scale="response")
visreg(fit2,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg2d(fit,"AGE","AV_TUBELENGTH_GP",
ylab = "Average Tube length", xlab="AGE",zlab="Probability Pregnancy",scale="response",plot.type = "persp",
phi=35,theta=47.5)
visreg2d(fit2,"AGE","PCA_TUBE_LENGTH",
ylab = "PC1", xlab="AGE",zlab="Probability Pregnancy",scale="response",plot.type = "persp",
phi=35,theta=47.5)
pca_dat <- data.frame(preg$LEFT_TUBE_LENGTH,preg$RIGHT_TUBE_LENGTH)
res.pca <- PCA(pca_dat, scale.unit = TRUE, ncp = 2, graph = TRUE)
fviz_pca_biplot(res.pca,
# Fill individuals by groups
geom.ind = "point",
pointshape = 21,
pointsize = 2.5,
fill.ind = preg$LIGATION_GROUP,
col.ind = "black",
repel = TRUE,        # Avoid label overplotting
legend.title = list(fill = "Ligation Group")
) +
ggpubr::fill_palette("jco")+      # Indiviual fill color
ggpubr::color_palette("npg")      # Variable colors
rocdf <- function(pred, obs, data=NULL, type=NULL) {
# plot_type is "roc" or "pr"
if (!is.null(data)) {
pred <- eval(substitute(pred), envir=data)
obs  <- eval(substitute(obs), envir=data)
}
rocr_xy <- switch(type, roc=c("tpr", "fpr"), pr=c("prec", "rec"))
rocr_df <- prediction(pred, obs)
rocr_pr <- performance(rocr_df, rocr_xy[1], rocr_xy[2])
xy <- data.frame(rocr_pr@x.values[[1]], rocr_pr@y.values[[1]])
# If PR, designate first (undefined) point as recall = 0, precision = x
if (type=="pr") {
xy[1, 2] <- 0
#xy <- xy[!(rowSums(xy)==0), ]
}
colnames(xy) <- switch(type, roc=c("tpr", "fpr"), pr=c("rec", "prec"))
return(xy)
}
# Pregnancy data
require(dplyr)
require(magrittr)
require(mgcv)
require(visreg)
library(FactoMineR)
require(caret)
library("factoextra")
library(pROC)
require(PRROC)
library(lime)
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AV_TUBELENGTH_GP",scale="response")
pdf("case1.pdf",height = 6,width = 6)
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AV_TUBELENGTH_GP",scale="response")
dev.off()
240000/12
100*12
100000*12
35000*12
