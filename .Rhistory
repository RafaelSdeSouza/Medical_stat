#                   erry = errobsy1,
N = N, # Sample size
M = M,
xx = xx
)
#
######################################################################
Model <- "model{
# LIKELIHOOD
for (i in 1:N) {
#obsy[i] ~ dnorm(y[i], pow(erry[i], -2))
obsy[i] ~ dnorm(sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0),pow(tau, -2))
res[i] <- obsy[i]-sfactorTdn3(obsx[i], e1,0.0912, gin, gout,6,5,0)
}
RSS <- sum(res^2)
# Predicted values
for (j in 1:M){
# Bare...
mux0[j] <- sfactorTdn3(xx[j], e1,0.0912, gin, gout,6,5,0)
}
# PRIORS
tau ~  dgamma(0.1,0.1)
e1 ~  dnorm(0,0.1)T(0,)
gin ~  dnorm(0,pow(0.5,-2))T(0,)
gout ~ dnorm(0,pow(0.5,-2))T(0,)
}"
######################################################################
# n.adapt:  number of iterations in the chain for adaptation (n.adapt)
#           [JAGS will use to choose the sampler and to assure optimum
#           mixing of the MCMC chain; will be discarded]
# n.udpate: number of iterations for burnin; these will be discarded to
#           allow the chain to converge before iterations are stored
# n.iter:   number of iterations to store in the final chain as samples
#           from the posterior distribution
# n.chains: number of mcmc chains
# n.thin:   store every n.thin element [=1 keeps all samples]
inits <- function () { list(e1 = runif(1,0.01,10),gout=runif(1,0.01,10),gin=runif(1,0.01,10)) }
# "f": is the model specification from above;
# data = list(...): define all data elements that are referenced in the
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 5000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 20,
burnin = 4000,
sample = 5000,
n.chains = 3)
Normfit <- run.jags(data = model.data,
adapt = 10000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 5,
burnin = 2000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit <- run.jags(data = model.data,
adapt = 20000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 10,
burnin = 1000,
sample = 5000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 1,
burnin = 1000,
sample = 10000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
# JAGS model with R2Jags;
Normfit <- run.jags(data = model.data,
adapt = 30000,
inits = inits,
method ="rjags",
monitor = c("e1", "gin", "gout","tau"),
model  = Model,
thin = 50,
burnin = 1000,
sample = 2000,
n.chains = 3)
plot(Normfit, layout=c(3,4))
Normfit
65000/12
123500000/12
65000000*0.81
52650000/12
98280/7.8
998280/7.8
127984.6/12
1346940/7.8
172684.6/12
14000*3.2
2700*3.3
4*5
2700/5
2300+500
2800/5
3200+560
3760*3.3
3760*3.4
900*3.4
900*3.42
900*4
3700*4
830/1596
install.packages("rJava",type = "source",http://rforge.net")
install.packages("rJava",type = "source","http://rforge.net")
install.packages("rJava",type = "source",,"http://rforge.net")
# From: Bayesian Models for Astrophysical Data, Cambridge Univ. Press
# (c) 2017,  Joseph M. Hilbe, Rafael S. de Souza and Emille E. O. Ishida
#
# you are kindly asked to include the complete citation if you used this
# material in a publication
# Code 4.10 - Normal linear model in R using JAGS and including errors in variables
require(R2jags)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
errx <- rnorm(nobs, 0, sdobsx)
obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Diffuse normal priors for true x
for (i in 1:N){
x[i] ~ dnorm(0,1e-3)
}
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
obsx[i] ~ dnorm(x[i],pow(errx[i],-2))
mu[i] <- beta[1]+beta[2]*x[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*truex[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
errx
# Data
set.seed(1056)                   # set seed to replicate example
nobs = 1000                      # number of obs in model
sdobsx <- 1.25
truex <- rnorm(nobs,0,2.5)       # normal variable
#errx <- rnorm(nobs, 0, sdobsx)
#obsx <- truex + errx
obsx <- truex
beta1 <- -4
beta2 <- 7
sdy <- 1.25
sdobsy <- 2.5
erry <- rnorm(nobs, 0, sdobsy)
truey <- rnorm(nobs,beta1 + beta2*truex,sdy)
obsy <- truey + erry
K <- 2
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
erry
print(evfit,intervals=c(0.025, 0.975), digits=3)
# Level of  mistake in the reported errors
Lambda <- 0.5
model.data <- list(obsy = obsy,
obsx = obsx,
K = K,
errx = errx,
erry = Lambda*erry,
N = nobs)
NORM_err <-" model{
# Diffuse normal priors for predictors
for (i in 1:K) { beta[i] ~ dnorm(0, 1e-3) }
# Uniform prior for standard deviation
tauy <- pow(sigma, -2)                               # precision
sigma ~ dunif(0, 100)                                # diffuse prior for standard deviation
# Likelihood
for (i in 1:N){
obsy[i] ~ dnorm(y[i],pow(erry[i],-2))
y[i] ~ dnorm(mu[i],tauy)
mu[i] <- beta[1]+beta[2]*obsx[i]
}
}"
# Initial values
inits <- function () {
list(beta = rnorm(K, 0, 0.01))
}
# Parameter to display and save
params <- c("beta", "sigma")
evfit <- jags(data = model.data,
inits = inits,
parameters = params,
model = textConnection(NORM_err),
n.chains = 3,
n.iter = 5000,
n.thin = 1,
n.burnin = 2500)
print(evfit,intervals=c(0.025, 0.975), digits=3)
setwd("~/")
erry
library(shiny)
library(DT)
shinyApp(
ui = fluidPage(
dataTableOutput('table'),
verbatimTextOutput('hoverIndex')
),
server = function(server, input, output) {
output$hoverIndex <- renderText({
paste("hover column info", input$hoverIndexJS)
})
output$table <- renderDataTable({
datatable(data.frame(`A` = 1:5, `B` = 11:15, `C` = LETTERS[1:5]),
rownames = F,
callback = JS("
table.on('mouseenter', 'td', function() {
Shiny.onInputChange('hoverIndexJS', this.innerHTML);
});
return table;
")
)
})
}
)
175/8
175*4
library("TDA", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
Diag <- matrix(c(0, 0, 10, 1, 0, 3, 1, 3, 8), ncol = 3, byrow = TRUE)
DiagLim <- 10
colnames(Diag) <- c("dimension", "Birth", "Death")
#persistence landscape
tseq <- seq(0,DiagLim, length = 1000)
Land <- landscape(Diag, dimension = 1, KK = 1, tseq)
par(mfrow = c(1,2))
plot.diagram(Diag)
plot(tseq, Land, type = "l", xlab = "t", ylab = "landscape", asp = 1)
library(dplyr)
library(tidyr)
library(DT)
library(sparkline)
dat <- readRDS("data.rds")
datatable(dat, rownames = FALSE)
dat <- iris3
datatable(dat, rownames = FALSE)
dat <- iris
datatable(dat, rownames = FALSE)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
js <- "function(data, type, full){ return '<span class=spark>' + data + '</span>' }"
colDefs1 <- list(list(targets = c(1:3), render = JS(js)))
d1 <- datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Var == "Species")$Val)
dat
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
r <- range(filter(dat, Species == "setosa")$Val)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
range(filter(dat, Species == "setosa")$Val)
filter(dat, Species == "setosa")
range(dat$Petal.Length)
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
datatable(dat_t1, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
r <- range(dat$Petal.Length)
x <- "function (oSettings, json) { $('.spark:not(:has(canvas))').sparkline('html', { "
line_string <- "type: 'line', lineColor: 'black', fillColor: '#ccc', highlightLineColor: 'orange', highlightSpotColor: 'orange'"
cb_line <- JS(paste0(x, line_string, ", chartRangeMin: ", r[1], ", chartRangeMax: ",
r[2], " }); }"), collapse = "")
d1 <- datatable(dat, rownames = FALSE, options = list(columnDefs = colDefs1,
fnDrawCallback = cb_line))
d1
1500/1200
0.25*1200
25/10
setwd("~/Documents/GitHub/Medical_stat")
# Pregnancy data
require(dplyr)
require(magrittr)
require(mgcv)
require(visreg)
library(FactoMineR)
require(caret)
library("factoextra")
library(pROC)
require(PRROC)
library(lime)
preg <- read.csv("BTA-Patients-MAW.csv") %>% select(c("BECOME_PREGNANT","TUBELENGTH_R_DISTAL","PREGNANT_NUMERIC",
"TUBELENGTH_L_DISTAL","LIGATION_GROUP",
"AGE","RIGHT_TUBE_LENGTH","LEFT_TUBE_LENGTH",
"TUBELENGTH_R_PROX","TUBELENGTH_L_PROX","AV_TUBELENGTH_GP")) %>%
filter(AGE != "Yes") %>%  mutate(AGE = as.numeric(as.character(AGE)) )  %>%
filter(AGE > 10) %>%
na.omit() %>% mutate(LEFT_TUBE_LENGTH = as.numeric(as.character(LEFT_TUBE_LENGTH)) ) %>%
mutate(PCA_TUBE_LENGTH = -prcomp(data.frame(RIGHT_TUBE_LENGTH,LEFT_TUBE_LENGTH))$x[,1]) %>%
filter(BECOME_PREGNANT %in% c("Yes","No")) %>% droplevels()
trainIndex <- createDataPartition(preg$BECOME_PREGNANT, p = .5,
list = FALSE,
times = 1)
Train <- preg[trainIndex,]
Test  <- preg[-trainIndex,]
fit0 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)   + LIGATION_GROUP,data=Train,family = binomial(link="logit"))
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AV_TUBELENGTH_GP",scale="response")
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
fit0 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)   + LIGATION_GROUP,data=preg,family = binomial(link="logit"))
pdf("case0.pdf",height = 6,width = 6)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
fit0 <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=10)   + LIGATION_GROUP,data=preg,family = binomial(link="logit"))
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
pdf("case0.pdf",height = 6,width = 6)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
pdf("case0.pdf",height = 5,width = 8)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
pdf("case0.pdf",height = 5,width = 6)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
pdf("case0.pdf",height = 5,width = 6.5)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
nrow(preg)
fit <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=15)  + AV_TUBELENGTH_GP  + LIGATION_GROUP,data=preg,family= binomial(link="logit"))
pdf("case1.pdf",height = 5,width = 6.5)
visreg(fit,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
fit <- gam(BECOME_PREGNANT~s(AGE,bs="cr",k=10)  + AV_TUBELENGTH_GP  + LIGATION_GROUP,data=preg,family= binomial(link="logit"))
pdf("case1.pdf",height = 5,width = 6.5)
visreg(fit,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
dev.off()
visreg2d(fit,"AGE","AV_TUBELENGTH_GP",
ylab = "Average Tube length", xlab="AGE",zlab="Probability Pregnancy",scale="response",plot.type = "persp",
phi=35,theta=47.5)
visreg2d(fit,"AGE","AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "Average Tube length", xlab="AGE",zlab="Probability Pregnancy",scale="response",plot.type = "persp",
phi=35,theta=47.5)
visreg(fit,"AGE","AV_TUBELENGTH_GP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg(fit,"AGE",by="AV_TUBELENGTH_GP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg(fit,"AGE",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg(fit,"AGE",by="AV_TUBELENGTH_GP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="AGE",scale="response")
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="Average tube lenght",scale="response")
visreg(fit,"AV_TUBELENGTH_GP",by="LIGATION_GROUP",
ylab = "BECOME PREGNANT", xlab="Average tube lenght (cm)",scale="response")
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "Pregnancy probability", xlab="Age",scale="response")
pdf("case0.pdf",height = 5,width = 6.5)
visreg(fit0,"AGE",by="LIGATION_GROUP",
ylab = "Pregnancy probability", xlab="Age",scale="response")
dev.off()
144/24
